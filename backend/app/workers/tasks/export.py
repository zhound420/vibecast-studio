"""Audio export Celery task."""

from pathlib import Path
from typing import Dict, Any

from celery import shared_task

from app.config import settings


@shared_task(name="export_audio")
def export_audio_task(
    job_id: str,
    source_path: str,
    output_format: str = "mp3",
    quality: str = "high",
    include_chapters: bool = True,
    metadata: Dict[str, str] = None,
) -> Dict[str, Any]:
    """
    Export audio to different formats using FFmpeg.

    Args:
        job_id: Generation job ID
        source_path: Path to source WAV file
        output_format: Output format (mp3, wav)
        quality: Quality level (low, medium, high)
        include_chapters: Whether to include chapter markers
        metadata: Optional metadata to embed

    Returns:
        Result dictionary with output path
    """
    import subprocess
    from uuid import uuid4

    source = Path(source_path)
    if not source.exists():
        return {"status": "failed", "error": "Source file not found"}

    # Determine output path
    export_id = str(uuid4())
    output_dir = Path(settings.exports_path) / job_id
    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = output_dir / f"export_{export_id}.{output_format}"

    # Build FFmpeg command
    cmd = ["ffmpeg", "-y", "-i", str(source)]

    if output_format == "mp3":
        # MP3 encoding settings
        bitrate = {"low": "96k", "medium": "192k", "high": "320k"}.get(quality, "192k")
        cmd.extend([
            "-codec:a", "libmp3lame",
            "-b:a", bitrate,
        ])
    elif output_format == "wav":
        # Keep as WAV (just copy or convert sample format)
        cmd.extend([
            "-codec:a", "pcm_s16le",
        ])

    # Add metadata if provided
    if metadata:
        for key, value in metadata.items():
            cmd.extend(["-metadata", f"{key}={value}"])

    # Add AI-generated metadata
    cmd.extend([
        "-metadata", "comment=Generated by VibeCast Studio using VibeVoice AI",
        "-metadata", "encoder=VibeCast Studio v0.1.0",
    ])

    cmd.append(str(output_path))

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=600,  # 10 minute timeout
        )

        if result.returncode != 0:
            return {
                "status": "failed",
                "error": f"FFmpeg error: {result.stderr}",
            }

        return {
            "status": "completed",
            "export_id": export_id,
            "output_path": str(output_path),
            "format": output_format,
            "size_bytes": output_path.stat().st_size,
        }

    except subprocess.TimeoutExpired:
        return {"status": "failed", "error": "Export timed out"}
    except Exception as e:
        return {"status": "failed", "error": str(e)}


@shared_task(name="cleanup_old_files")
def cleanup_old_files():
    """Periodic task to clean up old generated files."""
    import time
    from datetime import datetime, timedelta

    # Files older than 7 days
    max_age_seconds = 7 * 24 * 60 * 60
    now = time.time()

    cleaned = 0

    for directory in [settings.audio_path, settings.exports_path]:
        if not directory.exists():
            continue

        for file_path in directory.rglob("*"):
            if file_path.is_file():
                file_age = now - file_path.stat().st_mtime
                if file_age > max_age_seconds:
                    try:
                        file_path.unlink()
                        cleaned += 1
                    except Exception:
                        pass

    return {"status": "completed", "files_cleaned": cleaned}
